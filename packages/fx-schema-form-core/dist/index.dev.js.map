{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 73e4483982d588f4913d","webpack:///./src/libs/resolve.ts","webpack:///./src/utils.ts","webpack:///./src/factory.ts","webpack:///./src/libs/factory.ts","webpack:///./src/index.ts","webpack:///./src/keys/index.ts","webpack:///./src/keys/ref.ts","webpack:///./src/keys/oneof.ts","webpack:///./src/keys/anyof.ts","webpack:///./src/keys/defined.ts","webpack:///./src/types/index.ts","webpack:///./src/types/array.ts","webpack:///./src/types/object.ts","webpack:///./src/types/none.ts","webpack:///./src/libs/merge.ts","webpack:///./src/libs/tree.ts"],"names":[],"mappings":"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","file":"index.dev.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SFC\"] = factory();\n\telse\n\t\troot[\"SFC\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 73e4483982d588f4913d","import { JSONSchema6 } from \"json-schema\";\n\nimport { schemaTypeFactory } from \"../factory\";\nimport { warn, isProd } from \"../utils\";\n\n/**\n* 解析path成成数据的路径\n* 最终schema需要与uiSchema做合并，uiSchema中的key配置的是数组 [\"appType', '-','type']，所以需要做一下转换\n* 1. 去掉properties，items关键字转换成【 - 】\n* 2. 第一个字符去掉末尾的【 # 】\n* @example design#/properties/appType => [\"appType']\n* @example design#/properties/appType/type => [\"appType','type']\n* @example design#/properties/appType/items/properties/type => [\"appType', '-', 'type']\n* @param {String}   schemaKey schema的path\n* @param {Boolean}  keepFirst 是否需要保留第一个\n*/\nexport const getDataKeys = (schemaKey: string, keepFirst = false): string[] => {\n    // let removeNextKey = false;\n    let keys = schemaKey.split(\"/\").map((key: string, index: number) => {\n        const regexp = /#$/g;\n\n        // 第一个替换末尾的#\n        if (index === 0 && regexp.test(key)) {\n            // 这里是regexp的陷阱,需要修改lastIndex = 0\n            // 对于同一个正则表达式对象regex，不能重复调用：第一次返回true，第二次就返回false，很显然这种效果不是我们想要的。\n            // 这是因为RegExp.test()方法，第一次从位置0开始查找，可以匹配；第二次的查找位置就不是0了，说以就不能匹配了。\n            regexp.lastIndex = 0;\n\n            return keepFirst ? key.replace(regexp, \"\") : null;\n        }\n\n        // 去掉properties\n        if (key === \"properties\") {\n            return null;\n        }\n\n        // 转换items成-\n        if (key === \"items\") {\n            return \"-\";\n        }\n\n        return key;\n    });\n\n    // 提取其中不为空的项\n    return keys.filter((key: string | null) => {\n        return key !== null;\n    }) as string[];\n};\n\n/**\n* 从schemaPath中获取$id\n* @param {String} schemaKey 当前schema的path\n*/\nexport const getSchemaId = (schemaKey: string): string => {\n    const keys = schemaKey.split(\"/\");\n    const regexp = /#$/g;\n\n    if (!keys.length) {\n        if (!isProd) {\n            warn(`${schemaKey} not a valid schemaPath.`);\n            // throw new Error(`${schemaKey} not a valid schemaPath.`);\n        }\n        return \"\";\n    }\n\n    return keys[0].replace(regexp, \"\");\n};\n\n/**\n * 解析schema中的字段，缓存到【schemaFieldFactory】中\n * 1. 验证schema的合法性\n * 2. 提取成map\n */\nexport default class ResolveLib {\n    public mergeSchema: JSONSchema6 = {};\n\n    /**\n     * 构造函数\n     * @param {Ajv}     ajv    当前的ajv实例\n     * @param {schema}  schema 当前的schema\n     * @param {String}  $id    schema的id\n     */\n    constructor(schema: JSONSchema6, readonly $id = \"\") {\n        // 验证schema的完整性\n        if (!$id) {\n            this.initSchema(schema);\n        }\n        // 生成map\n        this.compileSchema(schema, $id || schema.$ref || \"\");\n    }\n\n    /**\n     * 初始化schema\n     * 1. 判断$id，如果不存在，报错\n     * 2. 验证schema的结构是否正确，不正确报错\n     * 3. 若果ajv中不存在schema，则添加进ajv\n     * @param {Ajv}          ajv     ajv的实例\n     * @param {JSONSchema6}  schema  schema\n     */\n    private initSchema(schema: JSONSchema6): JSONSchema6 {\n        let $id: string | undefined = schema.$id;\n\n        // 如果没有$id, 同时没有$ref的情况下直接报错\n        if (!$id && !schema.$ref) {\n            if (!isProd) {\n                // throw new Error(`id is required.`);\n                warn(\"id is required\");\n            }\n            return schema;\n        }\n\n        // // 验证schema的正确性\n        // if (!ajv.validateSchema(schema)) {\n        //     throw ajv.errors;\n        // }\n\n        // // 把schema加入到ajv\n        // if ($id && !ajv.getSchema($id)) {\n        //     ajv.addSchema(schema);\n        // }\n\n        return schema;\n    }\n\n    /**\n     * 遍历schema，生成map\n     * 1. 如果schema.type不是string，报错\n     * 2. 调用【schemaTypeFactory\n     * @param {JSONSchema6} schema  schema\n     * @param {String}      $id     id\n     */\n    private compileSchema(schema: JSONSchema6, $id: string): void {\n        schema = schemaTypeFactory.get(\"undefined\")(schema, $id || (schema.$id || \"\") + \"#\");\n\n        this.mergeSchema = schema;\n\n        // 如果不存在type，则直接返回\n        if (!schema.type || schema.$ref) {\n            return;\n        }\n\n        // 这里只解析type为字符串的结构，不支持数组类型的type\n        if (schema.type.constructor !== String) {\n            if (!isProd) {\n                warn(`schema type[${schema.type}] can only be string.`);\n                // throw new Error(`schema type[${schema.type}] can only be string.`);\n            }\n            return;\n        }\n\n        const type: string = schema.type.toString();\n\n        // 这里调用相对应的type的方法，来解析schema\n        if (schemaTypeFactory.has(type)) {\n            this.mergeSchema = schemaTypeFactory.get(type)(schema, $id || (schema.$id || \"\") + \"#\");\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/libs/resolve.ts","/**\n * 判断是否是生产环境\n */\nexport const isProd = (() => {\n    const { NODE_ENV } = process.env;\n\n    return typeof NODE_ENV !== \"undefined\" && NODE_ENV === `\"production\"`;\n})();\n\n/**\n * 警告方法\n * @param   {string} message 消息内容\n * @returns {Error}\n */\nexport const warn = (message: string) => {\n    if (!isProd) {\n        console.error(message);\n    }\n    throw new Error(message);\n};\n\n/**\n * 暴露hasOwnProperty方法\n */\nexport const hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * 暴露toString方法\n */\nexport const toString = Object.prototype.toString;\n\nexport function typeOf(value: any) {\n    if (null === value) {\n        return \"null\";\n    }\n\n    let type = typeof value;\n\n    if (\"undefined\" === type || \"string\" === type) {\n        return type;\n    }\n\n    let typeString = toString.call(value);\n    switch (typeString) {\n        case \"[object Array]\":\n            return \"array\";\n        case \"[object Date]\":\n            return \"date\";\n        case \"[object Boolean]\":\n            return \"boolean\";\n        case \"[object Number]\":\n            return \"number\";\n        case \"[object Function]\":\n            return \"function\";\n        case \"[object RegExp]\":\n            return \"regexp\";\n        case \"[object Object]\":\n            if (undefined !== value.nodeType) {\n                if (3 === value.nodeType) {\n                    return /\\S/.test(value.nodeValue) ? \"textnode\" : \"whitespace\";\n                } else {\n                    return \"element\";\n                }\n            } else {\n                return \"object\";\n            }\n        default:\n            return \"unknow\";\n    }\n}\n\n/**\n * 判断参数是不是数字\n * @param   {Any}      n    需要验证的参数\n * @returns {Boolean}\n */\nexport const isNumber = (n: any): boolean => {\n    return typeOf(n) === \"number\";\n};\n\n/**\n * 判断参数是不是boolean\n * @param   {Any}      n    需要验证的参数\n * @returns {Boolean}\n */\nexport const isArray = (n: any): boolean => {\n    return typeOf(n) === \"array\";\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.ts","import { JSONSchema6 } from \"json-schema\";\n\nimport { BaseFactory } from \"./libs/factory\";\nimport { FxJsonSchema } from \"./models/jsonschema\";\n\nexport const schemaFieldFactory = new BaseFactory<FxJsonSchema>();\nexport const schemaKeyWordFactory = new BaseFactory<($id: string, schema: JSONSchema6) => JSONSchema6>();\nexport const schemaTypeFactory = new BaseFactory<(schema: JSONSchema6, $id: string) => JSONSchema6>();\nexport const schemaKeysFactory = new BaseFactory<string>();\n\n/**\n * 遍历所有的keyword，解析schema\n * @param   {JSONSchema6} schema schema\n * @returns {JSONSchema6}        解析过后的schema\n */\nexport const convertKeys = ($id: string, schema: JSONSchema6): JSONSchema6 => {\n    schemaKeyWordFactory.forEach((key: string, val: ($id: string, schema: JSONSchema6) => JSONSchema6) => {\n        if (schema) {\n            schema = val($id, schema);\n        }\n    });\n\n    return schema;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/factory.ts","import { hasOwnProperty } from \"../utils\";\n\n/**\n * 实例的工厂类\n */\nexport class BaseFactory<T> {\n    protected i: { [id: string]: T; } = {};\n    private pi: { [id: string]: boolean; } = {};\n\n    /**\n     * 添加一个实例\n     * @param  {string}  name       实例的名称\n     * @param  {T} intance    实例\n     * @param  {boolean} override   是否覆盖\n     * @return {void | boolean}     是否添加成功\n     */\n    public add(name: string, intance: T, override = false): BaseFactory<T> {\n        if (hasOwnProperty.call(this.pi, name) || !override && this.has(name)) {\n            return this;\n        }\n\n        this.i[name] = intance;\n\n        return this;\n    }\n\n    /**\n     * 是否存在key值\n     * @param  {String} key  key值\n     * @return {Boolean}\n     */\n    public has(key: string): boolean {\n        return hasOwnProperty.call(this.i, key);\n        // return this.i.hasOwnProperty(key);\n    }\n\n    /**\n     * 获取一个实例\n     * @param  {String} key   实例标志\n     * @return {T}\n     */\n    public get(key: string): T {\n        if (this.has(key)) {\n            return this.i[key];\n        }\n        // if (__DEV__) {\n        //     warn(`name=[${key}]not exist`);\n        // }\n\n        return null as any;\n    }\n\n    /**\n     * 锁定实例\n     * @param {String} key key\n     */\n    public lock(key: string): void {\n        if (this.has(key)) {\n            this.pi[key] = true;\n        }\n    }\n\n    /**\n     * 解锁实例\n     * @param key key\n     */\n    public unLock(key: string): void {\n        if (this.has(key)) {\n            delete this.pi[key];\n        }\n    }\n\n    /**\n     * 遍历所有的元素\n     * @param func 遍历方法\n     */\n    public forEach(func: (key: string, val: T) => any): void {\n        if (!func) {\n            return;\n        }\n\n        for (const key in this.i) {\n            if (this.has(key)) {\n                const element = this.i[key];\n\n                if (func(key, element) === false) {\n                    break;\n                }\n            }\n        }\n    }\n\n    /**\n     * 清空当前的hash\n     */\n    public clear(): void {\n        this.i = {};\n        this.pi = {};\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/libs/factory.ts","import { ref, oneof, anyof, definitions } from \"./keys/index\";\nimport { array, none, object } from \"./types/index\";\nimport { BaseFactory } from \"./libs/factory\";\nimport { schemaFieldFactory, schemaKeyWordFactory, schemaTypeFactory, schemaKeysFactory } from \"./factory\";\nimport { FxJsonSchema } from \"./models/jsonschema\";\nimport { UiSchema } from \"./models/uischema\";\nexport { default as ResolveLib, getSchemaId, getDataKeys } from \"./libs/resolve\";\nexport { default as MergeLib } from \"./libs/merge\";\nexport { TreeMap } from \"./libs/tree\";\nexport { typeOf, isArray, isNumber} from \"./utils\";\n\nschemaKeyWordFactory.add(\"definitions\", definitions)\n                    .add(\"oneof\", oneof)\n                    .add(\"anyof\", anyof)\n                    .add(\"ref\", ref);\n\nschemaTypeFactory.add(\"array\", array)\n                .add(\"string\", none)\n                .add(\"undefined\", none)\n                .add(\"number\", none)\n                .add(\"null\", none)\n                .add(\"any\", none)\n                .add(\"integer\", none)\n                .add(\"boolean\", none)\n                .add(\"object\", object);\n\nexport {\n    FxJsonSchema,\n    UiSchema,\n    BaseFactory,\n    schemaKeysFactory,\n    schemaFieldFactory,\n    schemaKeyWordFactory,\n    schemaTypeFactory\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.ts","export { default as ref } from \"./ref\";\nexport { default as oneof } from \"./oneof\";\nexport { default as anyof } from \"./anyof\";\nexport { default as definitions } from \"./defined\";\n\n\n\n// WEBPACK FOOTER //\n// ./src/keys/index.ts","import { JSONSchema6 } from \"json-schema\";\n\nimport { getDataKeys, getSchemaId } from \"../libs/resolve\";\nimport { warn, isProd } from \"../utils\";\nimport { schemaFieldFactory, schemaKeysFactory } from \"../factory\";\n\n/**\n * 解析schema中的关键字 ref\n * 如果有$ref关键字，则从ajv中获取$ref的schema\n * 如果ajv中发现了schema，则添加$ref和refKeys，返回schema\n * @param  {string}      $id    当前的schema的ID\n * @param  {JSONSchema6} schema 当前的schema\n * @return {JSONSchema6}        处理过后的schema\n */\nexport default ($id: string, schema: JSONSchema6) => {\n    if (schema && schema.$ref) {\n        const schemaId = getSchemaId(schema.$ref);\n        let refName = schema.$ref;\n\n        if (schema.$id) {\n            refName = schema.$id + schema.$ref;\n        } else if (!schemaId) {\n            refName = getSchemaId($id) + schema.$ref;\n        }\n        schema.$ref = refName;\n\n        if (!schemaFieldFactory.has(refName)) {\n            // throw new Error(`不存在Key为[${refName}]的schema!`);\n            schemaFieldFactory.add(refName, {});\n        }\n\n        const refSchema = schemaFieldFactory.get(refName);\n\n        if (refSchema) {\n            let schemaAjv = Object.assign({}, refSchema) as JSONSchema6;\n\n            schemaAjv.$ref = refName;\n            delete schemaAjv.$id;\n\n            Object.assign(schemaAjv, {\n                refKeys: getDataKeys(refName)\n            });\n\n            return schemaAjv;\n        }\n\n        if (!isProd) {\n            warn(`${refName} not exist.`);\n        }\n    }\n\n    return schema;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/keys/ref.ts","import { JSONSchema6 } from \"json-schema\";\n\nimport { default as ResolveLib } from \"../libs/resolve\";\nimport { isArray } from \"../utils\";\n\n/**\n * 解析schema中的关键字 oneOf\n * 如果发现有oneOf关键字，遍历替换成schema\n * @param  {string}      $id    当前的schema的ID\n * @param  {JSONSchema6} schema 当前的schema\n * @return {JSONSchema6}        处理过后的schema\n */\nexport default ($id: string, schema: JSONSchema6): JSONSchema6 => {\n    const oneOf = schema.oneOf;\n\n    if (oneOf && isArray(oneOf)) {\n        schema.oneOf = oneOf.map((schemaOfOne: JSONSchema6) => {\n            let { mergeSchema } = new ResolveLib(schemaOfOne);\n\n            return mergeSchema;\n        });\n    }\n\n    return schema;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/keys/oneof.ts","import { JSONSchema6 } from \"json-schema\";\n\nimport { default as ResolveLib, getSchemaId } from \"../libs/resolve\";\n// import MergeLib from \"../libs/merge\";\n\n/**\n * 解析schema中的关键字 oneOf\n * 如果发现有oneOf关键字，遍历替换成schema\n * @param  {string}      $id    当前的schema的ID\n * @param  {JSONSchema6} schema 当前的schema\n * @return {JSONSchema6}        处理过后的schema\n */\nexport default ($id: string, schema: JSONSchema6): JSONSchema6 => {\n    let anyOf = schema.anyOf;\n\n    if (anyOf && anyOf.constructor === Array) {\n        schema.anyOf = anyOf.map((schemaOfOne: JSONSchema6, index: number) => {\n            let { mergeSchema } = new ResolveLib(schemaOfOne, schema.$id || getSchemaId(schema.$ref || \"\") ? undefined : getSchemaId($id));\n\n            return mergeSchema;\n        });\n    }\n\n    return schema;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/keys/anyof.ts","import { JSONSchema6 } from \"json-schema\";\n\nimport { default as ResolveLib } from \"../libs/resolve\";\n\n/**\n * 解析schema中的关键字 definitions\n * 如果发现有definitions关键字，解析schema\n * @param  {string}      $id    当前的schema的ID\n * @param  {JSONSchema6} schema 当前的schema\n * @return {JSONSchema6}        处理过后的schema\n */\nexport default ($id: string, schema: JSONSchema6): JSONSchema6 => {\n    const definitions = schema.definitions;\n\n    if (!definitions) {\n        return schema;\n    }\n\n    for (const key in definitions) {\n        if (definitions.hasOwnProperty(key)) {\n            const element: JSONSchema6 | boolean = definitions[key];\n\n            if (element !== false && element !== true) {\n                // tslint:disable-next-line:no-unused-expression\n                new ResolveLib(element, `${schema.$id}#/definitions/${key}`);\n            }\n        }\n    }\n\n    return schema;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/keys/defined.ts","\nexport { default as array } from \"./array\";\nexport { default as object } from \"./object\";\nexport { default as none } from \"./none\";\n\n\n\n// WEBPACK FOOTER //\n// ./src/types/index.ts","import { JSONSchema6 } from \"json-schema\";\n\nimport { default as ResolveLib, getDataKeys } from \"../libs/resolve\";\n\nconst itemsName = \"items\";\n\n/**\n * 解析schema中的type=array的结构\n * 如果存在items,则继续解析schema.item\n * @param  {JSONSchema6} schema    当前的schema\n * @param  {String}      schemaKey 当前的schemaKey\n * @return {JSONSchema6}           返回处理过后的schema\n */\nexport default (schema: JSONSchema6, schemaKey: string) => {\n    let { items } = schema;\n\n    if (items) {\n        const propertySchemaResolve = new ResolveLib(items as JSONSchema6, [ schemaKey, itemsName ].join(\"/\")),\n            keys: string[] = getDataKeys([ schemaKey, itemsName ].join(\"/\"));\n\n        Object.assign(propertySchemaResolve.mergeSchema, {\n            keys\n        });\n    }\n\n    return schema;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/types/array.ts","import { JSONSchema6 } from \"json-schema\";\n\nimport { default as ResolveLib, getDataKeys } from \"../libs/resolve\";\nimport { warn, isProd } from \"../utils\";\n\nconst pro = \"properties\";\n\n/**\n * 解析schema中的type=object的结构\n * 如果存在schema.properties,则遍历properties，继续解析schema.properties[key]\n * @param  {JSONSchema6} schema    当前的schema\n * @param  {String}      schemaKey 当前的schemaKey\n * @return {JSONSchema6}           返回处理过后的schema\n */\nexport default (schema: JSONSchema6, schemaKey: string) => {\n    const { properties, required = [], $ref } = schema;\n\n    if (properties && !$ref) {\n        Object.keys(properties).forEach((key: string) => {\n            if ([ pro, \"items\" ].indexOf(key) >= 0) {\n                if (!isProd) {\n                    warn(`${key}can not be key words.`);\n                }\n                return;\n            }\n\n            if (!properties || !properties[key]) {\n                return;\n            }\n\n            Object.assign(properties[key], {\n                isRequired: required.indexOf(key) >= 0\n            });\n\n            const propertySchemaResolve = new ResolveLib(properties[key] as JSONSchema6, [ schemaKey, pro, key ].join(\"/\")),\n                keys: string[] = getDataKeys([ schemaKey, pro, key ].join(\"/\"));\n\n            Object.assign(propertySchemaResolve.mergeSchema, {\n                keys\n            });\n        });\n    }\n\n    return schema;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/types/object.ts","import { JSONSchema6 } from \"json-schema\";\n\nimport { schemaFieldFactory, schemaKeysFactory, convertKeys } from \"../factory\";\nimport { getDataKeys, getSchemaId } from \"../libs/resolve\";\n\n/**\n * 解析schema中的type!=array && type!=object的结构\n * @param  {JSONSchema6} schema    当前的schema\n * @param  {String}      schemaKey 当前的schemaKey\n * @return {JSONSchema6}           返回处理过后的schema\n */\nexport default (schema: JSONSchema6, schemaKey: string) => {\n    let keys: string[] = getDataKeys(schemaKey, false),\n        $id = getSchemaId(schemaKey),\n        currentSchema = convertKeys(schemaKey, schema),\n        alreadyHasEmptySchema = false,\n        emptySchema: any = {};\n\n    // 先从缓存中提取schema，如果存在的话\n    alreadyHasEmptySchema = schemaFieldFactory.has(schemaKey);\n    if (alreadyHasEmptySchema) {\n        emptySchema = schemaFieldFactory.get(schemaKey);\n    }\n\n    // 如果已经存在，则直接返回\n    if (alreadyHasEmptySchema && emptySchema.schemaPath) {\n        return currentSchema || schema;\n    }\n\n    if (!$id) {\n        $id = schema.$id || \"\";\n    }\n\n    if (schema.$id && schema.$ref) {\n        schemaKeysFactory.add(schema.$id, schema.$ref);\n    }\n\n    // 将当前获取的schema加入到schemaFieldFactory中\n    schemaFieldFactory.add(\n        schemaKey,\n        Object.assign(emptySchema, currentSchema || schema, {\n            keys,\n            schemaPath: schemaKey\n        })\n    );\n    // 加入key的索引\n    schemaKeysFactory.add([ $id ].concat(keys).join(\"/\"), schemaKey);\n\n    return currentSchema || schema;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/types/none.ts","import { UiSchema } from \"../models/uischema\";\nimport { schemaFieldFactory, schemaKeysFactory } from \"../factory\";\nimport { getDataKeys, getSchemaId } from \"./resolve\";\nimport { FxJsonSchema } from \"../models/jsonschema\";\nimport { warn, isProd } from \"../utils\";\n\n/**\n* 根据给出的parentKeys和uiSchemaKeys来获取uiSchema的key\n* 1. 遍历uiSchemaKeys，分别于parentKeys做合并\n* 2. 合并后的keys去仓库里面找，如果为找到则报错\n* 3. 判断找到的schema中是否带有 $ref\n* 4. 如果有$ref，则更改parentKeys为$ref的路径\n* 5. 如果没有，则更改parentKeys为当前合并的keys\n* @param  {String[]} uiSchemaKeys      当前的keys\n* @param  {String} parentSchemaPath    父亲的schemaPath\n* @return {String}                     返回的key\n*/\nconst getUiSchemaKeyRecursion = (uiSchemaKeys: string[], parentSchemaPath: string): string => {\n    let parentKeysWithDef = getDataKeys(parentSchemaPath, true);\n\n    while (uiSchemaKeys.length) {\n        const key: string = uiSchemaKeys.shift() || \"\";\n\n        parentKeysWithDef = parentKeysWithDef.concat(key ? [ key ] : []);\n\n        const keysStr: string = parentKeysWithDef.join(\"/\").replace(/\\/$/, \"\");\n\n        if (!schemaKeysFactory.has(keysStr)) {\n            if (!isProd) {\n                // console.log(schemaFieldFactory, schemaKeysFactory);\n                warn(`${keysStr} did not found.`);\n            }\n\n            return \"\";\n        }\n\n        const schema: FxJsonSchema = schemaFieldFactory.get(schemaKeysFactory.get(keysStr));\n\n        if (schema.$ref) {\n            parentKeysWithDef = getDataKeys(schema.$ref, true);\n        }\n        // else {\n        //     parentKeysWithDef = parentKeysWithDef;\n        // }\n    }\n\n    return parentKeysWithDef.join(\"/\");\n};\n/**\n  * 获取父亲的keys\n  * @param  {UiSchema}               parent 父亲schema\n  * @return {Array<string | number>}\n  */\nconst getParentSchemaKeys = (parent?: UiSchema): Array<string | number> => {\n    if (parent && parent.keys) {\n        return parent.keys;\n    }\n\n    return [];\n};\n\n/**\n * 获取当前uiSchema的key\n * 如果没有父亲节点\n * 默认返回父亲的key+当前uiSchema的key\n * @param  {UiSchema} parent      父亲schema\n * @param  {string}   schemaPath  schema的路径\n * @param  {UiSchema} uiSchema    uiSchma\n * @return {String}               返回的key\n */\nconst getCurrentSchemaKey = (parent: UiSchema | undefined, schemaPath: string, uiSchema: UiSchema): string => {\n    const $id = getSchemaId(schemaPath);\n    let uiSchemaKeys = uiSchema.key.split(\"/\");\n\n    // 如果父亲节点的shcemaId不是传入的schemaId，则不使用父亲的key做计算\n    if (parent && getSchemaId(parent.key) === $id) {\n        return getUiSchemaKeyRecursion(uiSchemaKeys, parent.schemaPath || \"\");\n    }\n\n    // const keys = getDataKeys(schemaPath, true);\n    // console.log(\"计算得出的keys\", $id, schemaPath, getDataKeys(schemaPath), getDataKeys(schemaPath, true));\n\n    // keys.pop();\n\n    return getUiSchemaKeyRecursion(uiSchemaKeys, schemaPath);\n};\n\n/**\n * 如果在【schemaKeysFactory】中没有发现uiSchema.key,则报错\n * 从【schemaKeysFactory】获取对应的schema，与uiSchema合并之后返回\n * @param  {UiSchema} uiSchema uiSchema\n * @return {UiSchema}          返回uiSchema\n */\nconst mergeUiSchemaToArray = (uiSchema: UiSchema): UiSchema => {\n    if (!schemaKeysFactory.has(uiSchema.key)) {\n        if (!isProd) {\n            console.log(schemaKeysFactory);\n            warn(`${uiSchema.key} did not found. do you forget to resolve schema first.`);\n        }\n\n        return uiSchema;\n    }\n\n    const schemaKey: string = schemaKeysFactory.get(uiSchema.key);\n    const schema = schemaFieldFactory.get(schemaKey);\n\n    return Object.assign({}, schema, uiSchema);\n};\n\n/**\n * 初始化uiSchema\n * 如果是字符串；用$id合并之后，获取schema\n * 如果是【UiSchema】；合并key之后，获取schema\n * @param  {UiSchema} parent      父亲schema\n * @param  {string}   schemaPath  schema的路径\n * @param  {UiSchema} uiSchema    uiSchma\n * @return {UiSchema}            返回uiSchema\n */\nconst initUiSchema = (parent: UiSchema | undefined, schemaPath: string, uiSchema: UiSchema): UiSchema => {\n    let parentKeys = getParentSchemaKeys(parent),\n        key = getCurrentSchemaKey(parent, schemaPath, uiSchema),\n        keys,\n        isRequired = false,\n        originSchema: FxJsonSchema = {},\n        schemaKey;\n\n    keys = parentKeys.concat(uiSchema.key ? uiSchema.key.split(\"/\") : []);\n\n    // if (parent.type === \"object\" && parent.required) {\n    //     const keys1 = keys.concat([]);\n\n    //     isRequired = parent.required.indexOf((keys1.pop() || \"\").toString()) >= 0;\n    // }\n\n    if (schemaKeysFactory.has(key)) {\n        schemaKey = schemaKeysFactory.get(key);\n        if (schemaFieldFactory.has(schemaKey)) {\n            originSchema = schemaFieldFactory.get(schemaKey);\n            // isRequired = originSchema.isRequired;\n        }\n    }\n\n    return Object.assign({ isRequired }, originSchema, uiSchema, {\n        key,\n        keys\n    });\n};\n\n/**\n * 合并后的数据添加到数组中去\n * 这里因为可以使用*,所有拆成了前面和后面以及*三个部分\n * @param  {UiSchema[]} uiSchemasFirst 前面部分\n * @param  {UiSchema[]} uiSchemasLast  后面部分\n * @param  {UiSchema}   uiSchema       需要处理的uiSchema\n * @return {Void}\n */\nconst pushMergeResult = (uiSchemasFirst: UiSchema[], uiSchemasLast: UiSchema[], uiSchema: UiSchema): void => {\n    if (\n        !uiSchemasFirst.concat(uiSchemasLast).filter((val: UiSchema) => {\n            return val.key === uiSchema.key;\n        }).length\n    ) {\n        uiSchema = mergeUiSchemaToArray(uiSchema);\n        uiSchemasFirst.push(uiSchema);\n    }\n};\n\n/**\n * 合并uiSchema\n * 1. 先判断uiSchema中是否存在*\n * 2. 如果没有*号，则遍历uiSchema，合并数据\n * 3. 如果存在*号；先合并*之前和*之后的uiSchema\n * 4. 遍历当前的schema：\n *    如果是object，则遍历properties，然后合并数据\n *    如果是array，则直接返回items，然后合并数据\n * @param  {UiSchema}                    parent      父亲的uiSchema\n * @param  {string}                      schemaPath  当前的schema路径\n * @param  {Array<UiSchema | string>}    uiSchemas   全部的uiSchemas\n * @param  {FxJsonSchema}                curSchema   当前的Schema\n * @return {UiSchema[]}                              合并后的uiSchemas\n */\n// tslint:disable-next-line:max-line-length\nconst initMergeSchema = (parent: UiSchema | undefined, schemaPath: string, uiSchemas: Array<UiSchema | string>, curSchema: FxJsonSchema): UiSchema[] => {\n    let idx: number = uiSchemas.indexOf(\"*\"),\n        uiSchemasFirst: UiSchema[] = [],\n        uiSchemasLast: UiSchema[] = [],\n        types = [ \"object\", \"array\" ];\n\n    // 如果存在多个*，则报错\n    if (uiSchemas.lastIndexOf(\"*\") !== idx) {\n        if (!isProd) {\n            // throw new Error(\"uiSchema can only has one *.\");\n            warn(\"uiSchema can only has one *.\");\n        }\n\n        return [];\n    }\n\n    // 不存在*号的情况\n    if (idx < 0) {\n        uiSchemas.slice(idx + 1).map((us: string | UiSchema) => {\n            let uiSchema = initUiSchema(parent, schemaPath, us.constructor === String ? { key: us } as UiSchema : us as UiSchema);\n\n            uiSchemasFirst.push(mergeUiSchemaToArray(uiSchema));\n        });\n\n        return uiSchemasFirst;\n    }\n\n    // 处理*之前的数据\n    uiSchemas.slice(0, idx).forEach((us: string | UiSchema) => {\n        let uiSchema = initUiSchema(parent, curSchema.schemaPath || schemaPath, us.constructor === String ? { key: us } as UiSchema : us as UiSchema);\n\n        uiSchemasFirst.push(mergeUiSchemaToArray(uiSchema));\n    });\n\n    // 处理*之后的数据\n    uiSchemas.slice(idx + 1).forEach((us: string | UiSchema) => {\n        let uiSchema = initUiSchema(parent, curSchema.schemaPath || schemaPath, us.constructor === String ? { key: us } as UiSchema : us as UiSchema);\n\n        uiSchemasLast.push(mergeUiSchemaToArray(uiSchema));\n    });\n\n    // 如果是object类型，遍历properties属性，与之前的数据去重后添加到数组\n    if (curSchema.type === types[0] && curSchema.properties) {\n        Object.keys(curSchema.properties).forEach((us: string) => {\n            const uiSchema = initUiSchema(parent, curSchema.schemaPath || schemaPath, {\n                key: us,\n                isRequired: curSchema.required ? curSchema.required.indexOf(us) >= 0 : false\n            } as UiSchema);\n\n            pushMergeResult(uiSchemasFirst, uiSchemasLast, uiSchema);\n        });\n    }\n\n    // 如果是数组，获取下一级的key，然后做对比处理\n    if (curSchema.type === types[1] && curSchema.items) {\n        const uiSchema = initUiSchema(parent, curSchema.schemaPath || schemaPath, {\n            key: \"-\"\n        });\n\n        pushMergeResult(uiSchemasFirst, uiSchemasLast, uiSchema);\n    }\n\n    // 是普通对象\n    if (types.indexOf(curSchema.type as string) < 0) {\n        let uiSchema = initUiSchema(parent, schemaPath, {\n            key: getDataKeys(curSchema.schemaPath || \"\", false).join(\"/\")\n        });\n\n        pushMergeResult(uiSchemasFirst, uiSchemasLast, uiSchema);\n    }\n\n    return uiSchemasFirst.concat(uiSchemasLast);\n};\n\n/**\n * 用来转换uiSchema的类\n * 如果有$ref，则直接使用\n */\nexport default class MergeLib {\n    /**\n     * 合并过后的数据\n     */\n    public mergeUiSchemaList: UiSchema[] = [];\n\n    /**\n     * 构造函数\n     * 1. 验证uiSchema的正确性\n     * 2. 处理uiSchema中带*号的数据\n     * 3. 返回合并后的数据\n     * @param {string}                    $id         schema的$id\n     * @param {UiSchema}                  parent      父亲的schema\n     * @param {Array<UiSchema | string>}  uiSchemas   uiSchema\n     */\n    constructor(schemaPath: string, parent?: UiSchema, uiSchemas?: Array<UiSchema | string>) {\n        uiSchemas = uiSchemas || [ \"*\" ];\n\n        // 获取schemaPath对应的schemaId\n        let keyPath: string = getDataKeys(schemaPath, true).join(\"/\");\n\n        // 如果keyPath还没有解析，则报错\n        if (!schemaKeysFactory.has(keyPath)) {\n            if (!isProd) {\n                warn(`${keyPath} not exist or ${keyPath} did not resolve yet.`);\n            }\n\n            return;\n        }\n\n        // 获取当前的schemaField\n        const curSchema = schemaFieldFactory.get(schemaKeysFactory.get(keyPath));\n\n        // 去掉$id这个字段\n        if (curSchema.$id) {\n            if (!curSchema.$ref) {\n                curSchema.$ref = curSchema.$id;\n            }\n            curSchema.$id = undefined;\n            delete curSchema.$id;\n        }\n\n        // 合并schema\n        this.mergeUiSchemaList = initMergeSchema(parent, schemaPath, uiSchemas, curSchema);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/libs/merge.ts","import { isNumber } from \"../utils\";\n\nexport type Tsn = string | number;\n\n/**\n * tree map struct\n * 这里用来记录数据的元数据信息\n * 元数据信息包括，isValid，isLoading，isShow，...etc\n */\nexport class TreeMap {\n    public children: TreeMap[] = [];\n\n    /**\n   * 构造函数\n   * @param   {String}  key    当前节点的key，用于计算位置\n   * @param   {any}     value  当前节点的值\n   * @param   {TreeMap} parent 当前节点的父亲节点\n   * @returns {Void}\n   */\n    constructor(private key: string, public value: any, public readonly parent?: TreeMap) {}\n\n    /**\n   * 添加一个孩子元素\n   * 这里需要构建一颗完整的树，所以要遍历keys来动态创建节点\n   * time complexity = O(1) / Constant\n   * @param    {Array<Tsn>} keys  节点的路径 example [\"root\",\"b\"]  root -> b\n   * @param    {any}        value 孩子的数据\n   * @returns  {TreeMap}\n   */\n    public addChild(keys: Array<Tsn>, value?: any): TreeMap {\n        let curNode: TreeMap = this;\n        let child: TreeMap | null = null;\n\n        if (!keys.length) {\n            return this;\n        }\n\n        keys = [ ...keys ];\n\n        // 创建所有路径的节点\n        while (keys.length) {\n            const key: Tsn = keys.shift() as Tsn;\n\n            child = curNode.contains(key);\n\n            // 这里需要做一下特殊处理\n            // 如果是数字的话，则说明是数组，key改成`-`\n            // 如果不是数组的话，则无所谓顺序，直接push就行\n            // 如果是数组，则要保证顺序和数据的下标一致\n            if (!child) {\n                if (isNumber(key)) {\n                    child = new TreeMap(\"-\", null, curNode);\n                    curNode.children[key as number] = child;\n                } else {\n                    child = new TreeMap(key.toString(), null, curNode);\n                    curNode.children.push(child);\n                }\n            }\n\n            curNode = child;\n        }\n\n        if (child) {\n            child.value = value;\n        }\n\n        return child as TreeMap;\n    }\n\n    /**\n   * 获取当前的key\n   * 如果key是`-`,代表是数组，则转换成数组下标\n   * time complexity = O(1) / Constant\n   * @returns string\n   */\n    public getKey(): string {\n        if (!this.key || this.key === \"-\") {\n            return this.getIndexInParent().toString();\n        }\n\n        return this.key;\n    }\n\n    /**\n   * 获取当前节点的keys路径\n   * time complexity = O(1) / Constant\n   * @returns {string[]}\n   */\n    public getCurrentKeys(): Array<Tsn> {\n        let keys: Array<Tsn> = [];\n\n        if (this.parent) {\n            keys = keys.concat(this.parent.getCurrentKeys());\n        }\n\n        return keys.concat([ this.key ]);\n    }\n\n    /**\n   * 获取当前节点在父亲children中的下标索引\n   * time complexity = O(1) / Constant\n   * @returns {number}\n   */\n    public getIndexInParent(): number {\n        if (this.parent) {\n            let children = this.parent.children;\n\n            for (let i = 0, n = children.length; i < n; i++) {\n                let child = children[i];\n\n                if (child && child === this) {\n                    return i;\n                }\n            }\n        }\n\n        return -1;\n    }\n\n    /**\n   * 从当前节点查找是否存在节点\n   * time complexity = O(n) / Linear\n   * @param   {Tsn}     key 节点的数据\n   * @returns {TreeMap}\n   */\n    public contains(key: Tsn): TreeMap | null {\n        // 如果是数字的话，直接返回children中对应下标的元素\n        if (isNumber(key)) {\n            if (this.children.length > key) {\n                let child = this.children[key as number];\n\n                if (!child) {\n                    this.children[key as number] = new TreeMap(\"-\", null, this);\n\n                    child = this.children[key as number];\n                }\n\n                return child;\n            }\n\n            return null;\n        }\n\n        // 如果当前节点的key===要搜索的key，则返回本身\n        if (this.getKey() === key) {\n            return this;\n        }\n\n        // 如果没有children，则返回空\n        if (!this.children || this.children.length === 0) {\n            return null;\n        }\n        // 遍历子节点，层层递归，直到找到\n        for (let i = 0; i < this.children.length; i++) {\n            let child = this.children[i];\n\n            if (child && child.contains(key)) {\n                return child;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n   * 根据给定的路径数组，返回对应的节点\n   * time complexity = O(n) / Linear\n   * @param   {Array<Tsn>}    keys路径\n   * @returns {TreeMap | null}\n   */\n    public containPath(keys: Array<Tsn>): TreeMap | null {\n        let node: TreeMap | null = this;\n\n        keys.forEach((key: Tsn) => {\n            if (!node) {\n                return null;\n            }\n            node = node.contains(key);\n\n            if (!node) {\n                return null;\n            }\n\n            return null;\n        });\n\n        return node;\n    }\n\n    /**\n   * 从父亲节点中删除当前节点\n   * time complexity = O(n) / Linear\n   */\n    public removeFromParent(): void {\n        let index = this.getIndexInParent();\n\n        if (this.parent) {\n            this.parent.children.splice(index, 1);\n        }\n    }\n\n    /**\n   * 移动到某个位置\n   * time complexity = O(1) / Linear\n   * @param   {Number} toIndex 需要移动到的位置\n   * @returns {Void}\n   */\n    public insertToFromParent(toIndex: number): void {\n        let curIndex = this.getIndexInParent();\n        let offset = toIndex > curIndex && false ? 1 : 0;\n        let splitIndex = toIndex;\n\n        // 如果没有父亲，或者父亲没有子节点，或者当前位置小于0\n        if (!this.parent || !this.parent.children || curIndex < 0) {\n            return;\n        }\n\n        // 如果超出了父亲的子节点数量，添加一个\n        if (this.parent.children.length <= toIndex) {\n            this.parent.addChild([ toIndex ]);\n        }\n\n        // 父亲节点中删除当前元素\n        this.removeFromParent();\n        // 将当前节点插入到制定的位置\n        // tslint:disable-next-line:max-line-length\n        this.parent.children = this.parent.children.concat([]).splice(0, splitIndex - offset).concat([ this ]).concat(this.parent.children.splice(splitIndex - offset));\n    }\n\n    /**\n   * 遍历指定节点下所有子节点的value数据,当前节点不计算在内\n   * @param   {(node: TreeMap) => any}     clearFunc      map方法\n   * @param   {Boolean}                    currentNode    是否包含当前节点\n   * @returns {Void}\n   */\n    public forEach(clearFunc: (node: TreeMap) => any, currentNode = false) {\n        if (currentNode) {\n            this.value = clearFunc(this);\n        }\n\n        if (!this.children) {\n            return;\n        }\n\n        for (let i = 0, n = this.children.length; i < n; i++) {\n            if (this.children[i]) {\n                this.children[i].value = clearFunc(this.children[i]);\n                this.children[i].forEach(clearFunc);\n            }\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/libs/tree.ts"],"sourceRoot":""}